// Generated by CoffeeScript 1.10.0
var FFMPEG, InputOutputParser, colors, ffmpeg, fs, nullable, path, shell;

colors = require('colors');

ffmpeg = require('fluent-ffmpeg');

shell = require('shelljs');

path = require('path');

fs = require('fs');

InputOutputParser = function(options) {
  var ext, file, output, parsed;
  file = options.file;
  parsed = path.parse(file);
  ext = options.ext ? options.ext : parsed.ext;
  output = parsed.dir + parsed.name + options.slug + ext;
  return output;
};

nullable = function() {
  if (process.platform === 'win32') {
    return 'nul';
  } else {
    return '/dev/null';
  }
};

FFMPEG = {
  exportAudioWaveform: function(options) {
    var extras, extrasArgs, output;
    output = InputOutputParser({
      file: options.file,
      ext: ".png",
      slug: "-waveform"
    });
    extras = "";
    if (options.extras) {
      extrasArgs = options.extras.split(",");
      extrasArgs.map(function(extra) {
        if (extra === 'downmixed') {
          extras += "aformat=channel_layouts=mono,";
        }
        if (extra === "compand") {
          return extras += "compand,";
        }
      });
    }
    return new Promise(function(resolve, reject) {
      return ffmpeg(options.file).addOption('-filter_complex', extras + "showwavespic=s=1280x240").addOption('-frames:v', '1').saveToFile(output).on('end', function() {
        return resolve({
          msg: "Output written to file " + output
        });
      }).on('error', function(err) {
        return resolve({
          msg: 'An error happened',
          error: err.message
        });
      });
    });
  },
  trimAudio: function(options) {
    var output;
    output = options.output || InputOutputParser({
      file: options.file,
      slug: "-trimmed"
    });
    return new Promise(function(resolve, reject) {
      return ffmpeg(options.file).addOption('-ss', options.start).addOption('-t', options.duration).saveToFile(output).on('end', function() {
        return resolve({
          msg: "Output written to file " + output
        });
      }).on('error', function(err) {
        return resolve({
          msg: 'An error happened',
          error: err.message
        });
      });
    });
  },
  changeSpeed: function(options) {
    var output, speed;
    speed = options.speed || 0.5;
    output = InputOutputParser({
      file: options.file,
      slug: "-speed-change"
    });
    return new Promise(function(resolve, reject) {
      return ffmpeg(options.file).addOption('-filter:a', "atempo=" + speed).saveToFile(output).on('end', function() {
        return resolve({
          msg: "Output written to file " + output
        });
      }).on('error', function(err) {
        return resolve({
          msg: 'An error happened',
          error: err.message
        });
      });
    });
  },
  reduceNoise: function(options) {
    var output;
    output = InputOutputParser({
      file: options.file,
      slug: "-reduced-noise"
    });
    return new Promise(function(resolve, reject) {
      return ffmpeg(options.file).addOption('-af', "highpass=f=200, lowpass=f=3000").saveToFile(output).on('end', function() {
        return resolve({
          msg: "Output written to file " + output
        });
      }).on('error', function(err) {
        return resolve({
          msg: 'An error happened',
          error: err.message
        });
      });
    });
  },
  convert: function(options) {
    var format, input, output;
    input = options.input;
    format = options.format;
    output = options.output;
    return new Promise(function(resolve, reject) {
      var binary, proc;
      if (!format) {
        reject({
          msg: "Error: Please provide a format",
          error: true
        });
      }
      if (!output) {
        output = path.parse(input);
        output = path.join(output.dir, output.name + "." + format);
      }
      binary = shell.which('ffmpeg');
      binary = "" + binary;
      proc = new ffmpeg({
        source: input,
        nolog: true
      });
      return proc.setFfmpegPath(binary).toFormat(format).saveToFile(output).on('end', function() {
        return resolve({
          msg: "File: " + input + " has been converted successfully"
        });
      }).on('error', function(err) {
        return resolve({
          msg: 'An error happened',
          error: err.message
        });
      });
    });
  },
  detectSilence: function(options) {
    var output;
    output = InputOutputParser({
      file: options.file,
      slug: "-detect-silence"
    });
    return new Promise(function(resolve, reject) {
      return ffmpeg(options.file).addOption('-af', "silencedetect=noise=" + options.noise + "dB:d=" + options.d).addOption('-f', "null").on('end', function(stdout, stderr) {

        /*
        				[silencedetect @ 0x7f95bad000c0] silence_end: 163.933 | silence_duration: 0.59288
        				[silencedetect @ 0x7f95bad000c0] silence_start: 167.287
        				[silencedetect @ 0x7f95bad000c0] silence_end: 167.88 | silence_duration: 0.59288
        				...
        				[silencedetect @ 0x7f95bad000c0] silence_start: 608.095
        				[silencedetect @ 0x7f95bad000c0] silence_end: 611.103 | silence_duration: 3.00776
        				[silencedetect @ 0x7f95bad000c0] silence_start: 611.299
         */
        var res, silenceDetect;
        silenceDetect = [];
        stderr.split("\n").filter(function(entry) {
          return ~entry.indexOf('[silencedetect @');
        }).map(function(entry) {
          var silence_end, silence_start;
          if (~entry.indexOf('silence_start')) {
            silence_start = entry.split("silence_start");
            silence_start = silence_start[1].replace(":", "").trim();
            silenceDetect.unshift({
              start: silence_start
            });
          }
          if (~entry.indexOf('silence_end')) {
            silence_end = entry.split("silence_end");
            silence_end = silence_end[1];
            silence_end = silence_end.split('|');
            silenceDetect[0].end = silence_end[0].replace(":", "").trim();
            return silenceDetect[0].duration = silence_end[1].replace("silence_duration:", "").trim();
          }
        });
        res = {};
        res.msg = silenceDetect.length ? "Silence detected" : "Silence not detected";
        if (silenceDetect.length) {
          res.data = silenceDetect.reverse();
        }
        return resolve(res);
      }).saveToFile(nullable());
    });
  },
  removeSilence: function(options) {
    var output;
    output = InputOutputParser({
      file: options.file,
      slug: "-debug"
    });
    return FFMPEG.detectSilence({
      file: options.file,
      noise: "-30",
      d: "0.5"
    }).then(function(res) {
      var counter, offset, pRes, split_files, tempSlug;
      pRes = Promise.resolve();
      offset = 0;
      counter = 0;
      split_files = [];
      tempSlug = "pa-ffmpeg-tmp-";
      res.data.forEach(function(entry) {
        return pRes = pRes.then(function() {
          var opts;
          opts = {
            file: options.file,
            start: offset,
            duration: entry.start - offset,
            output: tempSlug + counter + '.wav'
          };
          offset = entry.end;
          if (counter > 0) {
            split_files.push(tempSlug + counter + '.wav');
          }
          counter++;
          return FFMPEG.trimAudio(opts);
        });
      });
      return pRes.then(function(res) {
        var proc;
        proc = new ffmpeg({
          source: tempSlug + '0.wav',
          nolog: true
        });
        split_files.map(function(file) {
          return proc.mergeAdd(file);
        });
        return proc.mergeToFile(output, function() {}).on('end', function() {
          console.log("Cleaning up...");
          split_files.push(tempSlug + "0.wav");
          return split_files.map(function(file) {
            console.log("Removing " + file + "...");
            return fs.unlinkSync(file);
          });
        });
      }).then(function(res) {
        return {
          msg: 'files have been merged successfully into ' + output
        };
      })["catch"](console.log);
    })["catch"](console.log);
  },
  __volumeDetect: function(options) {
    return ffmpeg(file).withAudioFilter('volumedetect').on('error', function(err, stdout, stderr) {
      return console.log('Error: '.red, err.message, stdout, stderr);
    }).on('end', function(stdout, stderr) {
      var volumeDetect;
      volumeDetect = {};
      stderr.split("\n").filter(function(x) {
        return ~x.indexOf('Parsed_volumedetect');
      }).forEach(function(x) {
        x = x.substr(2 + x.indexOf('] '));
        x = x.split(': ');
        return volumeDetect[x[0]] = x[1];
      });
      return console.log(volumeDetect);
    }).saveToFile('tmp.wav');
  }
};

module.exports = FFMPEG;
